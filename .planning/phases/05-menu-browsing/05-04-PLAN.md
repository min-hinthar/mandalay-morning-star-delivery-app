---
phase: 05-menu-browsing
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ui-v8/menu/SearchInputV8.tsx
  - src/components/ui-v8/menu/SearchAutocomplete.tsx
autonomous: true

must_haves:
  truths:
    - "Search input shows autocomplete suggestions as user types"
    - "Autocomplete suggestions appear after debounced input (300ms)"
    - "Clicking a suggestion selects the item"
    - "Search can be cleared with X button"
  artifacts:
    - path: "src/components/ui-v8/menu/SearchInputV8.tsx"
      provides: "Search input with debounce and autocomplete trigger"
      exports: ["SearchInputV8"]
    - path: "src/components/ui-v8/menu/SearchAutocomplete.tsx"
      provides: "Dropdown list of search suggestions"
      exports: ["SearchAutocomplete"]
  key_links:
    - from: "SearchInputV8.tsx"
      to: "useDebounce hook"
      via: "import"
      pattern: "useDebounce.*300"
    - from: "SearchInputV8.tsx"
      to: "SearchAutocomplete.tsx"
      via: "composition"
      pattern: "<SearchAutocomplete"
---

<objective>
Build V8 search input with autocomplete suggestions that appear as user types, using existing hooks for debounce and menu search.

Purpose: MENU-04 requirement - search with autocomplete
Output: SearchInputV8 with autocomplete dropdown ready for menu integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-menu-browsing/05-RESEARCH.md

@src/lib/hooks/useDebounce.ts
@src/lib/hooks/useMenu.ts
@src/components/menu/search-input.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SearchAutocomplete dropdown</name>
  <files>src/components/ui-v8/menu/SearchAutocomplete.tsx</files>
  <action>
Create SearchAutocomplete component for displaying search suggestions:

```tsx
"use client";

import { motion, AnimatePresence } from "framer-motion";
import Image from "next/image";
import { Loader2 } from "lucide-react";
import type { MenuItem } from "@/types/menu";
import { formatPrice } from "@/lib/utils/currency";
import { spring } from "@/lib/motion-tokens";
import { useAnimationPreference } from "@/lib/hooks/useAnimationPreference";
import { cn } from "@/lib/utils/cn";

interface SearchAutocompleteProps {
  items: MenuItem[];
  isLoading: boolean;
  isOpen: boolean;
  onSelect: (item: MenuItem) => void;
  query: string;
}

export function SearchAutocomplete({
  items,
  isLoading,
  isOpen,
  onSelect,
  query,
}: SearchAutocompleteProps) {
  const { shouldAnimate, getSpring } = useAnimationPreference();

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={shouldAnimate ? { opacity: 0, y: -8 } : undefined}
        animate={{ opacity: 1, y: 0 }}
        exit={shouldAnimate ? { opacity: 0, y: -8 } : undefined}
        transition={shouldAnimate ? getSpring(spring.snappy) : { duration: 0 }}
        className={cn(
          "absolute top-full left-0 right-0 z-dropdown mt-1",
          "rounded-card border border-border bg-surface-primary shadow-elevated",
          "max-h-[300px] overflow-y-auto"
        )}
      >
        {isLoading ? (
          <div className="flex items-center justify-center p-4">
            <Loader2 className="h-5 w-5 animate-spin text-text-muted" />
          </div>
        ) : items.length === 0 ? (
          <div className="p-4 text-center text-text-muted">
            No results for "{query}"
          </div>
        ) : (
          <ul role="listbox">
            {items.map((item) => (
              <li key={item.id}>
                <button
                  type="button"
                  role="option"
                  // Use onMouseDown to fire before input blur
                  onMouseDown={(e) => {
                    e.preventDefault();
                    onSelect(item);
                  }}
                  className={cn(
                    "flex w-full items-center gap-3 p-3",
                    "transition-colors duration-fast",
                    "hover:bg-surface-secondary",
                    "focus-visible:outline-none focus-visible:bg-surface-secondary"
                  )}
                >
                  {/* Thumbnail */}
                  <div className="relative h-12 w-12 shrink-0 overflow-hidden rounded-input bg-surface-tertiary">
                    {item.imageUrl ? (
                      <Image
                        src={item.imageUrl}
                        alt=""
                        fill
                        sizes="48px"
                        className="object-cover"
                      />
                    ) : (
                      <span className="flex h-full items-center justify-center text-xl">
                        üçΩÔ∏è
                      </span>
                    )}
                  </div>

                  {/* Info */}
                  <div className="flex-1 min-w-0 text-left">
                    <p className="font-medium text-text-primary truncate">
                      {item.nameEn}
                    </p>
                    {item.nameMy && (
                      <p className="text-sm text-text-muted font-burmese truncate">
                        {item.nameMy}
                      </p>
                    )}
                  </div>

                  {/* Price */}
                  <span className="shrink-0 font-display font-bold text-primary">
                    {formatPrice(item.basePriceCents)}
                  </span>
                </button>
              </li>
            ))}
          </ul>
        )}
      </motion.div>
    </AnimatePresence>
  );
}
```

Key points:
- Use onMouseDown (not onClick) to prevent blur-before-click issue
- z-dropdown for proper stacking
- Truncate long names
- Show thumbnail, name (both languages), price
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>SearchAutocomplete displays suggestions list with proper click handling</done>
</task>

<task type="auto">
  <name>Task 2: Create SearchInputV8 with debounce</name>
  <files>src/components/ui-v8/menu/SearchInputV8.tsx</files>
  <action>
Create SearchInputV8 component:

```tsx
"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Search, X, Loader2 } from "lucide-react";
import { useDebounce } from "@/lib/hooks/useDebounce";
import { useMenuSearch } from "@/lib/hooks/useMenu";
import type { MenuItem } from "@/types/menu";
import { SearchAutocomplete } from "./SearchAutocomplete";
import { cn } from "@/lib/utils/cn";

interface SearchInputV8Props {
  onSelectItem: (item: MenuItem) => void;
  placeholder?: string;
  className?: string;
}

export function SearchInputV8({
  onSelectItem,
  placeholder = "Search menu...",
  className,
}: SearchInputV8Props) {
  const [query, setQuery] = useState("");
  const [isFocused, setIsFocused] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false); // For mobile
  const inputRef = useRef<HTMLInputElement>(null);

  // Debounce search query by 300ms
  const debouncedQuery = useDebounce(query.trim(), 300);

  // Fetch search results using existing hook
  const { data, isFetching } = useMenuSearch(debouncedQuery);
  const items = data?.data?.items ?? [];

  // Show autocomplete when focused and has query
  const showAutocomplete = isFocused && debouncedQuery.length > 0;

  const handleClear = useCallback(() => {
    setQuery("");
    inputRef.current?.focus();
  }, []);

  const handleSelect = useCallback((item: MenuItem) => {
    setQuery("");
    setIsFocused(false);
    setIsExpanded(false);
    onSelectItem(item);
  }, [onSelectItem]);

  // Handle escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape" && isFocused) {
        setIsFocused(false);
        setIsExpanded(false);
        inputRef.current?.blur();
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [isFocused]);

  // Focus input when expanded on mobile
  useEffect(() => {
    if (isExpanded && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isExpanded]);

  return (
    <div className={cn("relative", className)}>
      {/* Mobile: Expandable search */}
      <div className="sm:hidden">
        <AnimatePresence mode="wait">
          {!isExpanded ? (
            <motion.button
              key="icon"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              onClick={() => setIsExpanded(true)}
              className={cn(
                "flex h-10 w-10 items-center justify-center",
                "rounded-full hover:bg-surface-secondary",
                "transition-colors duration-fast"
              )}
              aria-label="Open search"
            >
              <Search className="h-5 w-5 text-text-secondary" />
            </motion.button>
          ) : (
            <motion.div
              key="input"
              initial={{ width: 40, opacity: 0 }}
              animate={{ width: "calc(100vw - 120px)", opacity: 1 }}
              exit={{ width: 40, opacity: 0 }}
              transition={{ type: "spring", stiffness: 300, damping: 30 }}
              className="absolute right-0 top-0"
            >
              <SearchField
                ref={inputRef}
                query={query}
                onChange={setQuery}
                onFocus={() => setIsFocused(true)}
                onBlur={() => setTimeout(() => setIsFocused(false), 150)}
                onClear={() => {
                  handleClear();
                  setIsExpanded(false);
                }}
                isLoading={isFetching}
                placeholder={placeholder}
              />
              <SearchAutocomplete
                items={items}
                isLoading={isFetching}
                isOpen={showAutocomplete}
                onSelect={handleSelect}
                query={debouncedQuery}
              />
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Desktop: Always visible */}
      <div className="hidden sm:block">
        <div className="relative w-64 lg:w-80">
          <SearchField
            ref={inputRef}
            query={query}
            onChange={setQuery}
            onFocus={() => setIsFocused(true)}
            onBlur={() => setTimeout(() => setIsFocused(false), 150)}
            onClear={handleClear}
            isLoading={isFetching}
            placeholder={placeholder}
          />
          <SearchAutocomplete
            items={items}
            isLoading={isFetching}
            isOpen={showAutocomplete}
            onSelect={handleSelect}
            query={debouncedQuery}
          />
        </div>
      </div>
    </div>
  );
}

// Internal search field component
interface SearchFieldProps {
  query: string;
  onChange: (value: string) => void;
  onFocus: () => void;
  onBlur: () => void;
  onClear: () => void;
  isLoading: boolean;
  placeholder: string;
}

const SearchField = React.forwardRef<HTMLInputElement, SearchFieldProps>(
  ({ query, onChange, onFocus, onBlur, onClear, isLoading, placeholder }, ref) => (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-text-muted" />
      <input
        ref={ref}
        type="search"
        inputMode="search"
        value={query}
        onChange={(e) => onChange(e.target.value)}
        onFocus={onFocus}
        onBlur={onBlur}
        placeholder={placeholder}
        className={cn(
          "h-10 w-full rounded-input pl-10 pr-10",
          "bg-surface-secondary border border-transparent",
          "text-text-primary placeholder:text-text-muted",
          "transition-all duration-fast",
          "focus:border-primary focus:bg-surface-primary focus:outline-none focus:ring-1 focus:ring-primary"
        )}
        aria-label="Search menu"
        aria-autocomplete="list"
      />
      {(query || isLoading) && (
        <button
          type="button"
          onClick={onClear}
          className={cn(
            "absolute right-2 top-1/2 -translate-y-1/2",
            "flex h-6 w-6 items-center justify-center",
            "rounded-full hover:bg-surface-tertiary",
            "transition-colors duration-fast"
          )}
          aria-label="Clear search"
        >
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin text-text-muted" />
          ) : (
            <X className="h-4 w-4 text-text-muted" />
          )}
        </button>
      )}
    </div>
  )
);
SearchField.displayName = "SearchField";
```

Add React import at top for forwardRef.
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>SearchInputV8 has debounced input, shows autocomplete via useMenuSearch, handles selection</done>
</task>

<task type="auto">
  <name>Task 3: Verify search integration</name>
  <files>src/components/ui-v8/menu/SearchInputV8.tsx</files>
  <action>
Verify the search components:

1. Check useMenuSearch hook exists and returns expected shape:
   - { data: { data: { items: MenuItem[] } }, isFetching: boolean }
   - If hook shape differs, adapt the data access

2. Verify useDebounce hook is correctly imported and used

3. Ensure z-dropdown token is available (from design-system tokens)

4. Run full verification:
   ```bash
   pnpm lint && pnpm typecheck
   ```

5. If useMenuSearch doesn't exist or has different API:
   - Check @/lib/hooks/useMenu.ts for actual export
   - May need to use useMenu with a query parameter instead
  </action>
  <verify>`pnpm lint && pnpm typecheck` passes</verify>
  <done>SearchInputV8 and SearchAutocomplete compile without errors</done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm lint` passes
- SearchInputV8 exports correctly
- SearchAutocomplete exports correctly
- Debounce is 300ms
- onMouseDown prevents blur-before-click issue
</verification>

<success_criteria>
- Typing in search input triggers debounced API call
- Autocomplete dropdown appears with results
- Clicking a suggestion calls onSelectItem
- Clear button clears query and closes autocomplete
- Mobile search expands from icon to input field
</success_criteria>

<output>
After completion, create `.planning/phases/05-menu-browsing/05-04-SUMMARY.md`
</output>
