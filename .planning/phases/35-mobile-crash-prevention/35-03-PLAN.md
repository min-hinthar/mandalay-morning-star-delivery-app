---
phase: 35-mobile-crash-prevention
plan: 03
type: execute
wave: 3
depends_on: ["35-02"]
files_modified:
  - src/components/**/*.tsx
  - src/lib/hooks/*.ts
  - .planning/phases/35-mobile-crash-prevention/35-TESTING.md
autonomous: false

must_haves:
  truths:
    - "All IntersectionObserver instances disconnect on unmount"
    - "All requestAnimationFrame calls cancel on unmount"
    - "All AudioContext instances close on unmount"
    - "All modals use useBodyScrollLock with deferRestore pattern"
    - "App passes 10-minute stress test on low-power mobile device"
  artifacts:
    - path: ".planning/phases/35-mobile-crash-prevention/35-TESTING.md"
      provides: "Testing checklist for manual verification"
      contains: "## Stress Test Scenarios"
  key_links:
    - from: "src/components/ui/Modal.tsx"
      to: "src/lib/hooks/useBodyScrollLock.ts"
      via: "useBodyScrollLock with deferRestore"
      pattern: "useBodyScrollLock.*deferRestore.*true"
---

<objective>
Fix all remaining Medium/High cleanup issues, apply scroll lock pattern to all modals, and verify with real device testing.

Purpose: Complete crash prevention by addressing remaining patterns and validating with stress tests on low-power devices.
Output: All cleanup issues resolved, TESTING.md checklist, verified zero crashes on iPhone SE/Android.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-mobile-crash-prevention/35-02-SUMMARY.md
@.planning/phases/35-mobile-crash-prevention/35-AUDIT.md
@src/lib/hooks/useBodyScrollLock.ts
@.claude/CLEANUP-PATTERNS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Remaining Cleanup Issues</name>
  <files>Files listed in AUDIT.md High/Medium sections for IntersectionObserver, rAF, AudioContext, async</files>
  <action>
Fix ALL remaining issues from AUDIT.md:

**1. IntersectionObserver cleanup (CRASH-08):**
```typescript
// Before
useEffect(() => {
  const observer = new IntersectionObserver(callback, options);
  elements.forEach(el => observer.observe(el));
  // No cleanup!
}, []);

// After
useEffect(() => {
  const observer = new IntersectionObserver(callback, options);
  elements.forEach(el => observer.observe(el));
  return () => observer.disconnect(); // Cleanup!
}, []);
```

**2. requestAnimationFrame cleanup (CRASH-07):**
```typescript
// Before
useEffect(() => {
  const animate = () => {
    doAnimation();
    requestAnimationFrame(animate);
  };
  requestAnimationFrame(animate);
  // No cleanup - animation continues forever!
}, []);

// After
const rafIdRef = useRef<number | null>(null);
useEffect(() => {
  const animate = () => {
    doAnimation();
    rafIdRef.current = requestAnimationFrame(animate);
  };
  rafIdRef.current = requestAnimationFrame(animate);
  return () => {
    if (rafIdRef.current !== null) {
      cancelAnimationFrame(rafIdRef.current);
      rafIdRef.current = null;
    }
  };
}, []);
```

**3. AudioContext cleanup (CRASH-06):**
```typescript
// Before
const playSound = () => {
  const ctx = new AudioContext(); // New context each time!
  // play sound
};

// After - use useSoundEffect hook or:
const audioContextRef = useRef<AudioContext | null>(null);
const getAudioContext = () => {
  if (!audioContextRef.current) {
    audioContextRef.current = new AudioContext();
  }
  return audioContextRef.current;
};
useEffect(() => {
  return () => {
    audioContextRef.current?.close();
    audioContextRef.current = null;
  };
}, []);
```

**4. Async operations without mount check (CRASH-02):**
For files with async setState without mount check, apply useSafeAsync or isMounted ref pattern:
```typescript
// Before
useEffect(() => {
  fetchData().then(data => setData(data)); // May fire after unmount
}, []);

// After
const { execute } = useSafeAsync();
useEffect(() => {
  execute(async () => {
    const data = await fetchData();
    return data;
  }).then(result => {
    if (result) setData(result);
  });
}, [execute]);
```

Run after each file:
- `pnpm typecheck`
- `pnpm lint`

Commit atomically per file.
  </action>
  <verify>
All High/Medium issues from AUDIT.md resolved
`pnpm typecheck && pnpm lint && pnpm build` passes
No IntersectionObserver without disconnect
No rAF without cancel
No AudioContext without close
  </verify>
  <done>All remaining cleanup issues fixed (CRASH-06, CRASH-07, CRASH-08 satisfied)</done>
</task>

<task type="auto">
  <name>Task 2: Apply useBodyScrollLock to All Modals</name>
  <files>All modal components in src/components/</files>
  <action>
Find ALL modal/drawer/overlay components and ensure they use useBodyScrollLock with deferRestore pattern (CRASH-09).

**Search for modal components:**
- Files with `Modal` in name
- Files with `Drawer` in name
- Files with `Dialog` in name
- Files with AnimatePresence that likely represent overlays

**Required pattern:**
```typescript
import { useBodyScrollLock } from '@/lib/hooks/useBodyScrollLock';

function Modal({ isOpen, onClose }) {
  const { restoreScrollPosition } = useBodyScrollLock(isOpen, {
    deferRestore: true  // CRITICAL for iOS Safari
  });

  return (
    <AnimatePresence onExitComplete={restoreScrollPosition}>
      {isOpen && (
        <motion.div exit={{ opacity: 0 }}>
          {/* Modal content */}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

**Checklist:**
- [ ] Modal.tsx - verify deferRestore: true
- [ ] CartDrawer.tsx - verify deferRestore: true
- [ ] MobileSearchModal.tsx - verify deferRestore: true
- [ ] CommandPalette.tsx - verify deferRestore: true
- [ ] Any other overlay components

If any modal does NOT have this pattern:
1. Add useBodyScrollLock import
2. Add deferRestore: true option
3. Add restoreScrollPosition to AnimatePresence onExitComplete
4. Commit: `fix(crash): add deferred scroll restore to ComponentName`
  </action>
  <verify>
All modal/drawer components use useBodyScrollLock with deferRestore: true
All AnimatePresence have onExitComplete={restoreScrollPosition}
`pnpm typecheck && pnpm lint` passes
  </verify>
  <done>All modals prevent iOS Safari crash via deferred scroll restoration (CRASH-09 satisfied)</done>
</task>

<task type="auto">
  <name>Task 3: Create Testing Checklist</name>
  <files>.planning/phases/35-mobile-crash-prevention/35-TESTING.md</files>
  <action>
Create comprehensive testing checklist for manual device verification.

```markdown
# Phase 35: Mobile Crash Prevention - Testing Checklist

**Created:** YYYY-MM-DD
**Test devices:**
- iPhone SE (2nd gen or newer) - iOS Safari
- Android mid-range (Samsung Galaxy A series or similar) - Chrome

## Pre-Test Setup

1. Clear browser cache and storage
2. Open Chrome DevTools (or Safari Web Inspector) Memory tab
3. Note starting memory usage
4. Set up screen recording for crash evidence

## Stress Test Scenarios

### Scenario 1: Rapid Modal Open/Close (CRASH-09)
**Duration:** 2 minutes
**Steps:**
1. Open homepage
2. Click any item to open modal
3. Close modal immediately
4. Repeat 50+ times rapidly
5. Monitor memory - should not grow continuously

**Pass criteria:**
- [ ] No crash
- [ ] Memory returns to baseline after closing
- [ ] No visual glitches

### Scenario 2: Fast Navigation (CRASH-02)
**Duration:** 2 minutes
**Steps:**
1. Navigate Home -> Menu -> Cart -> Home rapidly
2. Use browser back/forward buttons
3. Repeat 30+ times
4. Monitor for "setState on unmounted" warnings in console

**Pass criteria:**
- [ ] No crash
- [ ] No console warnings about unmounted components
- [ ] Navigation remains responsive

### Scenario 3: Scroll with Animations (CRASH-03, CRASH-04)
**Duration:** 3 minutes
**Steps:**
1. Load homepage with GSAP animations
2. Scroll up and down rapidly
3. Trigger scroll-based animations repeatedly
4. Navigate away and back
5. Repeat scroll stress

**Pass criteria:**
- [ ] No crash
- [ ] Animations replay correctly after navigation
- [ ] Memory does not grow with repeated scrolling

### Scenario 4: Audio Interactions (CRASH-06)
**Duration:** 1 minute
**Steps:**
1. Trigger any sound effects (button clicks, notifications)
2. Trigger sounds rapidly 20+ times
3. Navigate away and back
4. Trigger sounds again

**Pass criteria:**
- [ ] Sounds play correctly
- [ ] No audio glitches or silence
- [ ] No crash

### Scenario 5: 10-Minute Sustained Session (CRASH-10)
**Duration:** 10 minutes
**Steps:**
1. Start timer
2. Browse menu, add items to cart
3. Open/close modals
4. Navigate between sections
5. Scroll through long lists
6. Use search functionality
7. Continue normal usage for full 10 minutes

**Pass criteria:**
- [ ] No crash during entire session
- [ ] App remains responsive at end
- [ ] Memory stays under 100MB on iPhone SE
- [ ] No performance degradation

## Memory Monitoring

Record memory readings every 2 minutes during 10-minute test:
| Time | Memory (MB) | Notes |
|------|-------------|-------|
| 0:00 | | Starting |
| 2:00 | | |
| 4:00 | | |
| 6:00 | | |
| 8:00 | | |
| 10:00 | | Final |

**Expected:** Memory should stay relatively flat, not continuously grow.

## Test Results

**iPhone SE:**
- Date tested:
- iOS version:
- Result: [ ] PASS / [ ] FAIL
- Notes:

**Android mid-range:**
- Date tested:
- Device model:
- Android version:
- Result: [ ] PASS / [ ] FAIL
- Notes:

## Sign-off

- [ ] All scenarios passed on iPhone SE
- [ ] All scenarios passed on Android
- [ ] Memory stayed under limits
- [ ] No crashes during 10-minute sessions
- [ ] Phase 35 requirements CRASH-01 through CRASH-10 satisfied
```
  </action>
  <verify>TESTING.md exists with all 5 scenarios documented</verify>
  <done>Testing checklist ready for manual device verification</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete crash prevention implementation:
- All timer cleanup (setTimeout/setInterval)
- All event listener cleanup (addEventListener)
- All GSAP animations using useGSAP
- All observers with disconnect/cancel
- All modals with deferred scroll restore
- Testing checklist created
  </what-built>
  <how-to-verify>
**Quick verification (can do on any device):**
1. Open the app in browser
2. Open DevTools Console - check for any warnings
3. Open DevTools Memory tab - note baseline
4. Rapidly open/close modals 20 times
5. Navigate between pages rapidly 10 times
6. Check memory - should not have grown significantly

**Full verification (do on real device if available):**
1. Open 35-TESTING.md
2. Run through Scenarios 1-4 (quick tests)
3. If time permits, run Scenario 5 (10-minute test)
4. Document results in TESTING.md

**Minimum to pass:**
- No crashes during quick verification
- No console warnings about unmounted components
- Memory does not continuously grow
  </how-to-verify>
  <resume-signal>
Type "approved" if verification passes, or describe any crashes/issues found
  </resume-signal>
</task>

</tasks>

<verification>
- All AUDIT.md issues resolved (Critical, High, Medium)
- All modals use deferred scroll restore pattern
- TESTING.md checklist exists
- Human verification passes on real device
</verification>

<success_criteria>
- CRASH-01 through CRASH-10 all satisfied
- Zero crashes during stress tests
- Memory stable during 10-minute session
- Human verification checkpoint approved
</success_criteria>

<output>
After completion, create `.planning/phases/35-mobile-crash-prevention/35-03-SUMMARY.md`
</output>
