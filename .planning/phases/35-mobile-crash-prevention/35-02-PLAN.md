---
phase: 35-mobile-crash-prevention
plan: 02
type: execute
wave: 2
depends_on: ["35-01"]
files_modified:
  - src/components/**/*.tsx
  - src/lib/hooks/*.ts
  - .claude/ERROR_HISTORY.md
autonomous: true

must_haves:
  truths:
    - "All setTimeout/setInterval calls have cleanup functions"
    - "All addEventListener calls have matching removeEventListener"
    - "All GSAP animations use useGSAP hook"
  artifacts:
    - path: ".claude/ERROR_HISTORY.md"
      provides: "Error patterns documented for future reference"
      contains: "## Timer Cleanup"
  key_links:
    - from: "src/components/**/*.tsx"
      to: "src/lib/hooks/useSafeEffects.ts"
      via: "import { useSafeTimeout }"
      pattern: "import.*useSafeEffects"
---

<objective>
Fix all Critical and High severity cleanup issues identified in AUDIT.md (timers, event listeners, GSAP).

Purpose: Eliminate crash-causing issues and major memory leaks by applying cleanup patterns to all affected files.
Output: All Critical and High issues from audit fixed, ERROR_HISTORY.md updated with patterns.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-mobile-crash-prevention/35-01-SUMMARY.md
@.planning/phases/35-mobile-crash-prevention/35-AUDIT.md
@src/lib/hooks/useSafeEffects.ts
@.claude/CLEANUP-PATTERNS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Timer Cleanup Issues</name>
  <files>Files listed in AUDIT.md Critical section for setTimeout/setInterval</files>
  <action>
For EACH file in AUDIT.md with setTimeout/setInterval issues:

1. **Determine best fix approach:**
   - If timer is in callback/handler: Use useSafeTimeout/useSafeInterval hook
   - If timer is simple in useEffect: Add clearTimeout/clearInterval to cleanup function
   - If timer needs to be rescheduled: Use ref pattern (timeoutRef.current)

2. **Apply fix following CLEANUP-PATTERNS.md:**

For useSafeTimeout conversion:
```typescript
// Before
useEffect(() => {
  const timeout = setTimeout(() => doSomething(), 1000);
  // No cleanup!
}, []);

// After
const { set: setSafeTimeout, clear: clearSafeTimeout } = useSafeTimeout();
useEffect(() => {
  setSafeTimeout(() => doSomething(), 1000);
}, [setSafeTimeout]);
```

For ref-based pattern (when callback creates timers):
```typescript
const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

const handleAction = useCallback(() => {
  if (timeoutRef.current) clearTimeout(timeoutRef.current);
  timeoutRef.current = setTimeout(() => {
    doSomething();
    timeoutRef.current = null;
  }, 1000);
}, []);

useEffect(() => {
  return () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
}, []);
```

3. **Run verification after each file:**
   - `pnpm typecheck`
   - `pnpm lint`

4. **Commit atomically:**
   - One commit per file: `fix(crash): add timer cleanup to ComponentName`
  </action>
  <verify>
All setTimeout/setInterval Critical issues from AUDIT.md resolved
`pnpm typecheck` passes
`pnpm lint` passes
Each file has cleanup function for all timers
  </verify>
  <done>All timer-related cleanup issues fixed with proper clearTimeout/clearInterval patterns</done>
</task>

<task type="auto">
  <name>Task 2: Fix Event Listener Cleanup Issues</name>
  <files>Files listed in AUDIT.md Critical section for addEventListener</files>
  <action>
For EACH file in AUDIT.md with addEventListener issues:

1. **Identify the handler reference problem:**
   - Is handler inline function? (creates new reference each time)
   - Is handler useCallback with wrong deps? (reference changes)
   - Is handler stored in ref? (correct pattern)

2. **Apply fix following CLEANUP-PATTERNS.md:**

For stable callback pattern:
```typescript
// Before (handler reference changes each render)
useEffect(() => {
  const handler = () => doSomething(count);
  window.addEventListener('resize', handler);
  return () => window.removeEventListener('resize', handler); // Different handler!
}, [count]);

// After (stable reference via ref or single useCallback)
const handlerRef = useRef<() => void>(() => {});
handlerRef.current = () => doSomething(count);

useEffect(() => {
  const handler = () => handlerRef.current();
  window.addEventListener('resize', handler);
  return () => window.removeEventListener('resize', handler); // Same handler!
}, []); // Empty deps = stable handler
```

For simple cases (no dependencies):
```typescript
useEffect(() => {
  const handler = () => doSomething();
  window.addEventListener('scroll', handler);
  return () => window.removeEventListener('scroll', handler);
}, []);
```

3. **Run verification after each file:**
   - `pnpm typecheck`
   - `pnpm lint`

4. **Commit atomically:**
   - One commit per file: `fix(crash): add event listener cleanup to ComponentName`
  </action>
  <verify>
All addEventListener Critical issues from AUDIT.md resolved
`pnpm typecheck` passes
`pnpm lint` passes
Each addEventListener has matching removeEventListener in cleanup
  </verify>
  <done>All event listener cleanup issues fixed with proper removeEventListener patterns</done>
</task>

<task type="auto">
  <name>Task 3: Migrate GSAP to useGSAP + Update ERROR_HISTORY.md</name>
  <files>Files listed in AUDIT.md High section for GSAP, .claude/ERROR_HISTORY.md</files>
  <action>
**Part A: GSAP Migration**

For EACH file in AUDIT.md with GSAP issues (gsap.to/from/fromTo in useEffect):

1. **Convert to useGSAP hook:**
```typescript
// Before
import gsap from 'gsap';
useEffect(() => {
  gsap.to('.box', { x: 100 });
  // No cleanup - animation persists after unmount!
}, []);

// After
import { gsap, useGSAP } from '@/lib/gsap';
const containerRef = useRef<HTMLDivElement>(null);
useGSAP(() => {
  gsap.to('.box', { x: 100 });
  // Auto-cleanup by useGSAP context!
}, { scope: containerRef });
```

2. **For animations in event handlers, use contextSafe:**
```typescript
const { contextSafe } = useGSAP({ scope: containerRef });
const handleClick = contextSafe(() => {
  gsap.to('.box', { rotation: 180 });
});
```

3. **For ScrollTrigger, include in useGSAP scope:**
```typescript
useGSAP(() => {
  ScrollTrigger.create({
    trigger: '.section',
    onEnter: () => gsap.to('.box', { opacity: 1 })
  });
  // Auto-cleanup - no manual ScrollTrigger.kill() needed!
}, { scope: containerRef });
```

4. **Commit atomically:**
   - One commit per file: `fix(crash): migrate ComponentName to useGSAP`

**Part B: Update ERROR_HISTORY.md**

Append new entry to `.claude/ERROR_HISTORY.md`:
```markdown
## 2026-01-30 - Timer and Event Listener Cleanup (Phase 35)

**Type:** Memory Leak / Crash
**Severity:** Critical
**Files:** [List all fixed files]

**Error:** Memory leaks and crashes on mobile from uncleaned timers, event listeners, and GSAP animations

**Root Cause:**
- setTimeout/setInterval without clearTimeout/clearInterval in useEffect cleanup
- addEventListener without matching removeEventListener (handler reference mismatch)
- GSAP animations in useEffect without context.revert() cleanup
- Particularly severe on iOS Safari due to 100MB memory limit on iPhone SE

**Fix:**
1. Timer cleanup: Use useSafeTimeout/useSafeInterval from useSafeEffects.ts
2. Event listener cleanup: Store handler in ref for stable reference
3. GSAP cleanup: Use useGSAP from @/lib/gsap (auto-handles context.revert)

**Prevention:**
- Always use useSafeTimeout/useSafeInterval for timers
- Always return cleanup function from useEffect
- Always use useGSAP instead of raw gsap.to() in React
- See .claude/CLEANUP-PATTERNS.md for examples
```
  </action>
  <verify>
All GSAP High issues from AUDIT.md resolved
All components use useGSAP or contextSafe patterns
`pnpm typecheck` passes
`pnpm lint` passes
ERROR_HISTORY.md updated with Phase 35 patterns
  </verify>
  <done>All GSAP animations use useGSAP with automatic cleanup, ERROR_HISTORY.md documents patterns for future reference</done>
</task>

</tasks>

<verification>
- All Critical issues (timers, event listeners) from AUDIT.md resolved
- All High GSAP issues from AUDIT.md resolved
- `pnpm typecheck && pnpm lint && pnpm build` passes
- ERROR_HISTORY.md has Phase 35 entry with patterns
</verification>

<success_criteria>
- Zero Critical issues remaining in codebase (CRASH-01, CRASH-02, CRASH-05 satisfied)
- Zero High GSAP issues remaining (CRASH-03, CRASH-04 satisfied)
- Patterns documented in ERROR_HISTORY.md for future reference
</success_criteria>

<output>
After completion, create `.planning/phases/35-mobile-crash-prevention/35-02-SUMMARY.md`
</output>
