---
phase: 20-micro-interactions
plan: 03
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/components/ui-v8/cart/QuantitySelector.tsx
  - src/components/ui/animated-image.tsx
  - src/lib/hooks/useSoundEffect.ts
autonomous: true

must_haves:
  truths:
    - "Quantity selector has rubbery spring overshoot on number change"
    - "Images reveal with blur-to-sharp effect plus scale"
    - "Sound effects play on key interactions when enabled"
  artifacts:
    - path: "src/components/ui-v8/cart/QuantitySelector.tsx"
      provides: "Enhanced quantity selector with rubbery spring"
      contains: "rubbery|overshoot"
    - path: "src/components/ui/animated-image.tsx"
      provides: "Image with blur-to-sharp reveal animation"
      contains: "filter.*blur|scale"
    - path: "src/lib/hooks/useSoundEffect.ts"
      provides: "Sound effect hook for interactions"
      contains: "AudioContext|play"
  key_links:
    - from: "src/components/ui-v8/cart/QuantitySelector.tsx"
      to: "src/lib/motion-tokens.ts"
      via: "imports rubbery spring"
      pattern: "spring.rubbery"
---

<objective>
Enhance specialized controls (quantity selector, images) and add sound effect infrastructure.

Purpose: Quantity changes should feel rubbery and satisfying, images should reveal elegantly, key actions can have optional sound.

Output: Enhanced QuantitySelector, new AnimatedImage component, useSoundEffect hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-micro-interactions/20-CONTEXT.md
@.planning/phases/20-micro-interactions/20-RESEARCH.md
@src/lib/motion-tokens.ts
@src/components/ui-v8/cart/QuantitySelector.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance QuantitySelector with rubbery spring overshoot</name>
  <files>src/components/ui-v8/cart/QuantitySelector.tsx</files>
  <action>
Upgrade the existing QuantitySelector to use rubbery spring with visible overshoot:

1. Import spring.rubbery from motion-tokens.ts (already has: stiffness: 350, damping: 8, mass: 1)
2. Change the flip animation transition from spring.snappy to spring.rubbery for the number display
3. Increase the y offset for more dramatic flip: 20 -> 28 pixels
4. Add scale animation to the number: 0.7 -> 1.1 -> 1 (overshoot effect)
5. Add subtle rotate to the flip: -5deg -> 0 for natural feel
6. Keep button animations with snappy spring (buttons should feel quick)
7. Add "pop" sound effect trigger point (use triggerHaptic pattern, actual sound in future)

The rubbery spring (damping: 8) will naturally overshoot and settle, creating a satisfying "flip counter" feel.

Keep all existing props and accessibility features.
  </action>
  <verify>`pnpm typecheck` passes. QuantitySelector number animates with visible overshoot.</verify>
  <done>QuantitySelector has rubbery spring with scale overshoot on number change.</done>
</task>

<task type="auto">
  <name>Task 2: Create AnimatedImage component with blur-to-sharp reveal</name>
  <files>src/components/ui/animated-image.tsx</files>
  <action>
Create an image component with blur-to-sharp + scale reveal animation:

```tsx
"use client";

import { useState } from "react";
import { motion } from "framer-motion";
import Image, { type ImageProps } from "next/image";
import { cn } from "@/lib/utils/cn";
import { spring } from "@/lib/motion-tokens";
import { useAnimationPreference } from "@/lib/hooks/useAnimationPreference";

interface AnimatedImageProps extends Omit<ImageProps, "onLoad"> {
  /** Reveal animation variant */
  variant?: "blur" | "fade" | "scale" | "blur-scale";
  /** Delay before animation starts (seconds) */
  delay?: number;
  /** Custom blur amount for blur variants */
  blurAmount?: number;
  /** Whether to animate on viewport enter (default: true) */
  animateOnView?: boolean;
}

const revealVariants = {
  blur: {
    hidden: { filter: "blur(20px)", opacity: 0 },
    visible: { filter: "blur(0px)", opacity: 1 },
  },
  fade: {
    hidden: { opacity: 0 },
    visible: { opacity: 1 },
  },
  scale: {
    hidden: { scale: 1.1, opacity: 0 },
    visible: { scale: 1, opacity: 1 },
  },
  "blur-scale": {
    hidden: { filter: "blur(20px)", scale: 1.1, opacity: 0 },
    visible: { filter: "blur(0px)", scale: 1, opacity: 1 },
  },
};

export function AnimatedImage({
  variant = "blur-scale",
  delay = 0,
  blurAmount = 20,
  animateOnView = true,
  className,
  alt,
  ...imageProps
}: AnimatedImageProps) {
  const { shouldAnimate, isFullMotion } = useAnimationPreference();
  const [isLoaded, setIsLoaded] = useState(false);

  // Custom variants with configurable blur
  const customVariants = {
    hidden: {
      ...(variant.includes("blur") && { filter: `blur(${blurAmount}px)` }),
      ...(variant.includes("scale") && { scale: 1.1 }),
      opacity: 0,
    },
    visible: {
      filter: "blur(0px)",
      scale: 1,
      opacity: 1,
    },
  };

  const handleLoad = () => {
    setIsLoaded(true);
  };

  // No animation - render plain image
  if (!shouldAnimate) {
    return (
      <Image
        className={className}
        alt={alt}
        onLoad={handleLoad}
        {...imageProps}
      />
    );
  }

  return (
    <motion.div
      className={cn("overflow-hidden", className)}
      initial="hidden"
      animate={isLoaded ? "visible" : "hidden"}
      whileInView={animateOnView ? "visible" : undefined}
      viewport={animateOnView ? { once: true, margin: "-50px" } : undefined}
      variants={customVariants}
      transition={{
        ...spring.gentle,
        delay,
        filter: { duration: 0.4, ease: "easeOut" },
      }}
    >
      <Image
        className="w-full h-full object-cover"
        alt={alt}
        onLoad={handleLoad}
        {...imageProps}
      />
    </motion.div>
  );
}

/**
 * Lazy-loaded image with placeholder blur
 * Uses next/image built-in blur placeholder + animated reveal
 */
export function LazyAnimatedImage({
  className,
  blurDataURL,
  placeholder = "blur",
  ...props
}: AnimatedImageProps & { blurDataURL?: string }) {
  const { shouldAnimate } = useAnimationPreference();
  const [isLoaded, setIsLoaded] = useState(false);

  if (!shouldAnimate) {
    return (
      <Image
        className={className}
        placeholder={placeholder}
        blurDataURL={blurDataURL}
        onLoad={() => setIsLoaded(true)}
        {...props}
      />
    );
  }

  return (
    <motion.div
      className={cn("relative overflow-hidden", className)}
      initial={{ opacity: 0, scale: 1.05 }}
      animate={isLoaded ? { opacity: 1, scale: 1 } : { opacity: 0, scale: 1.05 }}
      transition={spring.gentle}
    >
      <Image
        className="w-full h-full object-cover"
        placeholder={placeholder}
        blurDataURL={blurDataURL}
        onLoad={() => setIsLoaded(true)}
        {...props}
      />
    </motion.div>
  );
}

export default AnimatedImage;
```

Key features:
- Multiple variants: blur, fade, scale, blur-scale (default)
- Configurable blur amount
- Optional animate-on-viewport-enter
- Works with next/image for optimization
- Respects animation preference
- LazyAnimatedImage variant uses built-in blur placeholder
  </action>
  <verify>`pnpm typecheck` passes. Component exports AnimatedImage and LazyAnimatedImage.</verify>
  <done>AnimatedImage component exists with blur-to-sharp + scale reveal animation.</done>
</task>

<task type="auto">
  <name>Task 3: Create useSoundEffect hook for interaction sounds</name>
  <files>src/lib/hooks/useSoundEffect.ts</files>
  <action>
Create a hook for playing sound effects on interactions:

```tsx
"use client";

import { useCallback, useRef, useEffect, useState } from "react";
import { useAnimationPreference } from "./useAnimationPreference";

// Sound effect types
export type SoundEffect = "click" | "success" | "error" | "pop" | "swoosh";

// Base64 encoded short sounds (placeholder - actual audio files would be better)
// For now, use Web Audio API to generate simple tones
const SOUND_CONFIG: Record<SoundEffect, { frequency: number; duration: number; type: OscillatorType }> = {
  click: { frequency: 800, duration: 0.05, type: "sine" },
  success: { frequency: 600, duration: 0.1, type: "triangle" },
  error: { frequency: 200, duration: 0.15, type: "square" },
  pop: { frequency: 1000, duration: 0.03, type: "sine" },
  swoosh: { frequency: 400, duration: 0.08, type: "sawtooth" },
};

/**
 * Hook for playing sound effects
 * Respects user preferences and manages AudioContext lifecycle
 *
 * @example
 * const { play, isEnabled, toggle } = useSoundEffect();
 * <button onClick={() => { play("click"); handleClick(); }}>Click</button>
 */
export function useSoundEffect() {
  const { isFullMotion } = useAnimationPreference();
  const audioContextRef = useRef<AudioContext | null>(null);
  const [hasInteracted, setHasInteracted] = useState(false);
  const [isEnabled, setIsEnabled] = useState(() => {
    if (typeof window === "undefined") return true;
    return localStorage.getItem("soundEffectsEnabled") !== "false";
  });

  // Initialize AudioContext on first user interaction
  useEffect(() => {
    const handleInteraction = () => {
      if (!hasInteracted) {
        setHasInteracted(true);
        // Create AudioContext lazily
        try {
          audioContextRef.current = new (window.AudioContext || (window as unknown as { webkitAudioContext: typeof AudioContext }).webkitAudioContext)();
        } catch {
          // AudioContext not supported
        }
      }
    };

    window.addEventListener("click", handleInteraction, { once: true });
    window.addEventListener("touchstart", handleInteraction, { once: true });

    return () => {
      window.removeEventListener("click", handleInteraction);
      window.removeEventListener("touchstart", handleInteraction);
    };
  }, [hasInteracted]);

  // Cleanup AudioContext on unmount
  useEffect(() => {
    return () => {
      audioContextRef.current?.close();
    };
  }, []);

  const play = useCallback(
    (effect: SoundEffect) => {
      // Skip if sounds disabled or reduced motion or no interaction yet
      if (!isEnabled || !isFullMotion || !hasInteracted) return;

      const ctx = audioContextRef.current;
      if (!ctx) return;

      try {
        const config = SOUND_CONFIG[effect];
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);

        oscillator.type = config.type;
        oscillator.frequency.setValueAtTime(config.frequency, ctx.currentTime);

        // Fade out to avoid clicks
        gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + config.duration);

        oscillator.start(ctx.currentTime);
        oscillator.stop(ctx.currentTime + config.duration);
      } catch {
        // Silently fail if audio playback fails
      }
    },
    [isEnabled, isFullMotion, hasInteracted]
  );

  const toggle = useCallback(() => {
    const newValue = !isEnabled;
    setIsEnabled(newValue);
    localStorage.setItem("soundEffectsEnabled", String(newValue));
  }, [isEnabled]);

  return {
    /** Play a sound effect */
    play,
    /** Whether sound effects are enabled */
    isEnabled,
    /** Toggle sound effects on/off */
    toggle,
    /** Whether user has interacted (required for autoplay policy) */
    hasInteracted,
  };
}

/**
 * Simpler hook that just returns a play function
 */
export function usePlaySound() {
  const { play } = useSoundEffect();
  return play;
}

export default useSoundEffect;
```

Key features:
- Web Audio API for generating simple tones (no external files needed)
- Respects animation preference (no sound in reduced motion)
- User can toggle sounds on/off (persisted to localStorage)
- Handles browser autoplay policy (waits for user interaction)
- Proper cleanup of AudioContext
- Multiple sound types: click, success, error, pop, swoosh
  </action>
  <verify>`pnpm typecheck` passes. Hook exports useSoundEffect and usePlaySound.</verify>
  <done>useSoundEffect hook exists with Web Audio API sound generation.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` - All TypeScript compiles
2. `pnpm lint` - No linting errors
3. `pnpm build` - Production build succeeds
4. Manual verification: QuantitySelector overshoots, AnimatedImage reveals with blur, sounds play on click
</verification>

<success_criteria>
- QuantitySelector has rubbery spring with visible overshoot effect
- AnimatedImage reveals with blur-to-sharp + scale animation
- useSoundEffect hook generates audio on key interactions
- All components respect useAnimationPreference
- `pnpm build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/20-micro-interactions/20-03-SUMMARY.md`
</output>
